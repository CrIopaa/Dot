<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>TAP ‚Ä¢ THE ‚Ä¢ DOT</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Archivo+Black&display=swap');
    
    html {
      overflow: hidden;
      height: 100%;
      width: 100%;
      position: fixed;
      overscroll-behavior: none;
      -webkit-overflow-scrolling: none;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: none;
      -webkit-user-drag: none;
    }
    
    body {
      font-family: 'Space Mono', monospace;
      background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
      height: 100dvh; /* Use dynamic viewport height for mobile */
      width: 100vw;
      width: 100dvw;
      position: fixed;
      top: 0;
      left: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 2s ease;
      overscroll-behavior: none;
      -webkit-overflow-scrolling: none;
    }
    
    /* Dynamic backgrounds */
    body.bg-space {
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
    }
    
    body.bg-galaxy {
      background: linear-gradient(135deg, #4b0082 0%, #000428 50%, #1a1a2e 100%);
    }
    
    body.bg-neon {
      background: linear-gradient(135deg, #0f0f23 0%, #1a0033 50%, #2d0047 100%);
    }
    
    body.bg-cyber {
      background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
      filter: brightness(0.5);
    }
    
    body.bg-underwater {
      background: linear-gradient(135deg, #003d5c 0%, #001f3f 50%, #000814 100%);
    }
    
    body.bg-abyss {
      background: linear-gradient(135deg, #001219 0%, #005f73 30%, #0a9396 60%, #94d2bd 100%);
      filter: brightness(0.6);
    }
    
    body.bg-lava {
      background: linear-gradient(135deg, #590d22 0%, #800f2f 50%, #c9184a 100%);
      filter: brightness(0.4);
    }
    
    body.bg-void {
      background: radial-gradient(ellipse at center, #000000 0%, #0d0d0d 100%);
    }
    
    /* Additional themed backgrounds */
    body.bg-neon-street {
      background: linear-gradient(135deg, #0f0f23 0%, #8b00ff 50%, #ff006e 100%);
      filter: brightness(0.55);
    }
    
    body.bg-cyber-rain {
      background: linear-gradient(135deg, #001a33 0%, #004d99 50%, #0080ff 100%);
      filter: brightness(0.45);
    }
    
    body.bg-deep-ocean {
      background: linear-gradient(135deg, #000814 0%, #001d3d 50%, #003566 100%);
      filter: brightness(0.5);
    }
    
    body.bg-electric {
      background: linear-gradient(135deg, #1a0033 0%, #4d0099 50%, #8000ff 100%);
      filter: brightness(0.5);
    }
    
    /* Animated background elements */
    .bg-stars {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }
    
    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: twinkle 3s infinite;
      opacity: 0.8;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(1.2); }
    }
    
    /* Cyber rain effect */
    .cyber-rain {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }
    
    .rain-drop {
      position: absolute;
      width: 2px;
      height: 80px;
      background: linear-gradient(to bottom, transparent, rgba(0, 255, 255, 0.8), transparent);
      animation: rainFall linear infinite;
      opacity: 0.6;
    }
    
    @keyframes rainFall {
      0% { transform: translateY(-100px); opacity: 0; }
      10% { opacity: 0.6; }
      90% { opacity: 0.6; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    
    /* Underwater bubbles */
    .underwater-bubbles {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }
    
    .bubble {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.05));
      border: 1px solid rgba(255, 255, 255, 0.2);
      animation: bubbleFloat linear infinite;
    }
    
    @keyframes bubbleFloat {
      0% { transform: translateY(100vh) translateX(0); opacity: 0; }
      10% { opacity: 0.5; }
      90% { opacity: 0.5; }
      100% { transform: translateY(-100px) translateX(var(--drift)); opacity: 0; }
    }
    
    /* Lava particles */
    .lava-particles {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }
    
    .lava-particle {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 100, 0, 0.8), rgba(255, 0, 0, 0.3));
      animation: lavaFloat ease-in-out infinite;
      filter: blur(2px);
    }
    
    @keyframes lavaFloat {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
      50% { transform: translateY(-30px) scale(1.2); opacity: 0.9; }
    }
    
    /* Neon grid lines */
    .neon-grid {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
      background-image: 
        linear-gradient(rgba(255, 0, 255, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 40px 40px;
      animation: gridScroll 20s linear infinite;
      perspective: 1000px;
      transform-style: preserve-3d;
    }
    
    @keyframes gridScroll {
      0% { background-position: 0 0; }
      100% { background-position: 40px 40px; }
    }
    
    /* Animated background grid */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: gridMove 20s linear infinite;
      pointer-events: none;
      opacity: 0.5;
      z-index: 0;
    }
    
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      z-index: 1;
    }
    
    #gameArea {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(90vw, 600px);
      height: min(90vw, 600px);
      background: rgba(255, 255, 255, 0.02);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      box-shadow: 
        0 0 100px rgba(255, 71, 87, 0.2),
        inset 0 0 100px rgba(255, 71, 87, 0.05);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    #gameArea.active {
      border-color: rgba(255, 71, 87, 0.5);
      box-shadow: 
        0 0 150px rgba(255, 71, 87, 0.4),
        inset 0 0 100px rgba(255, 71, 87, 0.1);
    }
    
    .dot {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 30px rgba(255, 71, 87, 0.8),
        0 0 60px rgba(255, 71, 87, 0.4);
      animation: pulse 0.8s ease-in-out infinite;
      transition: transform 0.1s ease;
    }
    
    /* Larger invisible hitbox around the dot */
    .dot::before {
      content: '';
      position: absolute;
      top: -15px;
      left: -15px;
      right: -15px;
      bottom: -15px;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .dot:hover {
      transform: scale(1.1);
    }
    
    .dot:active {
      transform: scale(0.9);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .dot.shrinking {
      animation: shrink linear forwards;
    }
    
    @keyframes shrink {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    
    /* Enemy dot styling */
    .dot.enemy {
      background: radial-gradient(circle, #ff0000 0%, #990000 100%) !important;
      box-shadow: 
        0 0 30px rgba(255, 0, 0, 0.9),
        0 0 60px rgba(255, 0, 0, 0.5),
        inset 0 0 20px rgba(0, 0, 0, 0.3) !important;
      animation: enemyPulse 0.5s ease-in-out infinite !important;
      border: 2px solid rgba(255, 0, 0, 0.8);
    }
    
    @keyframes enemyPulse {
      0%, 100% { 
        transform: scale(1); 
        filter: brightness(1);
      }
      50% { 
        transform: scale(1.1); 
        filter: brightness(1.3);
      }
    }
    
    .dot.enemy.shrinking {
      animation: enemyShrink linear forwards !important;
    }
    
    @keyframes enemyShrink {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    
    /* Power-up dot styles */
    .dot.powerup-gold {
      background: radial-gradient(circle, #ffd700 0%, #ffaa00 100%) !important;
      box-shadow: 
        0 0 40px rgba(255, 215, 0, 1),
        0 0 80px rgba(255, 215, 0, 0.6) !important;
      animation: goldPulse 0.6s ease-in-out infinite !important;
      border: 3px solid rgba(255, 215, 0, 0.9);
    }
    
    @keyframes goldPulse {
      0%, 100% { transform: scale(1) rotate(0deg); filter: brightness(1); }
      50% { transform: scale(1.15) rotate(10deg); filter: brightness(1.4); }
    }
    
    .dot.powerup-freeze {
      background: radial-gradient(circle, #00ffff 0%, #0088ff 100%) !important;
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 1),
        0 0 80px rgba(0, 255, 255, 0.6) !important;
      animation: freezePulse 0.8s ease-in-out infinite !important;
      border: 3px solid rgba(0, 255, 255, 0.9);
    }
    
    @keyframes freezePulse {
      0%, 100% { transform: scale(1); filter: brightness(1) hue-rotate(0deg); }
      50% { transform: scale(1.12); filter: brightness(1.3) hue-rotate(20deg); }
    }
    
    .dot.powerup-shield {
      background: radial-gradient(circle, #00ff88 0%, #00aa44 100%) !important;
      box-shadow: 
        0 0 40px rgba(0, 255, 136, 1),
        0 0 80px rgba(0, 255, 136, 0.6) !important;
      animation: shieldPulse 0.7s ease-in-out infinite !important;
      border: 3px solid rgba(0, 255, 136, 0.9);
    }
    
    @keyframes shieldPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.13); box-shadow: 0 0 60px rgba(0, 255, 136, 1); }
    }
    
    .dot.powerup-multiplier {
      background: radial-gradient(circle, #ff00ff 0%, #aa00ff 100%) !important;
      box-shadow: 
        0 0 40px rgba(255, 0, 255, 1),
        0 0 80px rgba(255, 0, 255, 0.6) !important;
      animation: multiplierPulse 0.5s ease-in-out infinite !important;
      border: 3px solid rgba(255, 0, 255, 0.9);
    }
    
    @keyframes multiplierPulse {
      0%, 100% { transform: scale(1) rotate(0deg); }
      50% { transform: scale(1.14) rotate(-10deg); filter: brightness(1.5); }
    }
    
    /* Skin styles */
    .skin-classic {
      background: radial-gradient(circle, #ff4757 0%, #ff6348 100%);
      box-shadow: 
        0 0 30px rgba(255, 71, 87, 0.8),
        0 0 60px rgba(255, 71, 87, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.3);
    }
    
    .skin-leopard {
      background: 
        radial-gradient(circle at 20% 30%, #000 8%, transparent 8%),
        radial-gradient(circle at 60% 20%, #000 6%, transparent 6%),
        radial-gradient(circle at 80% 60%, #000 7%, transparent 7%),
        radial-gradient(circle at 30% 70%, #000 9%, transparent 9%),
        radial-gradient(circle at 70% 80%, #000 6%, transparent 6%),
        radial-gradient(circle at 50% 50%, #000 5%, transparent 5%),
        radial-gradient(circle at 15% 85%, #000 7%, transparent 7%),
        radial-gradient(circle at 85% 35%, #000 8%, transparent 8%),
        linear-gradient(135deg, #f4a460 0%, #d2691e 100%);
      box-shadow: 
        0 0 30px rgba(244, 164, 96, 0.8),
        0 0 60px rgba(210, 105, 30, 0.4),
        inset 0 0 20px rgba(0, 0, 0, 0.2);
    }
    
    .skin-military {
      background: 
        radial-gradient(ellipse at 15% 25%, #4a5d3a 15%, transparent 15%),
        radial-gradient(ellipse at 65% 35%, #3d4a2f 20%, transparent 20%),
        radial-gradient(ellipse at 85% 70%, #4a5d3a 18%, transparent 18%),
        radial-gradient(ellipse at 25% 75%, #3d4a2f 22%, transparent 22%),
        radial-gradient(ellipse at 45% 60%, #4a5d3a 16%, transparent 16%),
        radial-gradient(ellipse at 75% 15%, #3d4a2f 14%, transparent 14%),
        linear-gradient(135deg, #6b7c5a 0%, #5a6b4a 100%);
      box-shadow: 
        0 0 30px rgba(107, 124, 90, 0.8),
        0 0 60px rgba(90, 107, 74, 0.4),
        inset 0 0 20px rgba(0, 0, 0, 0.3);
    }
    
    .skin-tiger {
      background: 
        repeating-linear-gradient(
          45deg,
          #ff8c00,
          #ff8c00 15px,
          #000 15px,
          #000 25px
        );
      box-shadow: 
        0 0 30px rgba(255, 140, 0, 0.8),
        0 0 60px rgba(255, 140, 0, 0.4),
        inset 0 0 20px rgba(0, 0, 0, 0.2);
    }
    
    .skin-zebra {
      background: 
        repeating-linear-gradient(
          90deg,
          #fff,
          #fff 12px,
          #000 12px,
          #000 24px
        );
      box-shadow: 
        0 0 30px rgba(255, 255, 255, 0.8),
        0 0 60px rgba(200, 200, 200, 0.4),
        inset 0 0 20px rgba(0, 0, 0, 0.2);
    }
    
    .skin-neon {
      background: 
        radial-gradient(circle at 50% 50%, #00ffff 0%, #ff00ff 50%, #ffff00 100%);
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.8),
        0 0 80px rgba(255, 0, 255, 0.6),
        inset 0 0 30px rgba(255, 255, 255, 0.4);
      animation: neonPulse 1s ease-in-out infinite, pulse 0.8s ease-in-out infinite;
    }
    
    @keyframes neonPulse {
      0%, 100% { filter: hue-rotate(0deg) brightness(1.2); }
      50% { filter: hue-rotate(90deg) brightness(1.5); }
    }
    
    .skin-galaxy {
      background: 
        radial-gradient(circle at 30% 40%, #fff 1px, transparent 1px),
        radial-gradient(circle at 70% 20%, #fff 1px, transparent 1px),
        radial-gradient(circle at 50% 80%, #fff 1px, transparent 1px),
        radial-gradient(circle at 20% 70%, #fff 1px, transparent 1px),
        radial-gradient(circle at 80% 60%, #fff 1px, transparent 1px),
        radial-gradient(circle at 40% 30%, rgba(138, 43, 226, 0.8) 30%, transparent 30%),
        radial-gradient(ellipse at center, #4b0082 0%, #000428 100%);
      box-shadow: 
        0 0 40px rgba(138, 43, 226, 0.8),
        0 0 80px rgba(75, 0, 130, 0.6),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
    }
    
    .skin-lava {
      background: 
        radial-gradient(circle at 30% 30%, #ff4500 0%, transparent 50%),
        radial-gradient(circle at 70% 70%, #ff6347 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, #ff0000 0%, #8b0000 100%);
      box-shadow: 
        0 0 40px rgba(255, 69, 0, 1),
        0 0 80px rgba(255, 69, 0, 0.6),
        inset 0 0 30px rgba(255, 165, 0, 0.4);
      animation: lavaFlow 2s ease-in-out infinite, pulse 0.8s ease-in-out infinite;
    }
    
    @keyframes lavaFlow {
      0%, 100% { filter: brightness(1) saturate(1.2); }
      50% { filter: brightness(1.3) saturate(1.5); }
    }
    
    #hud {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      z-index: 10;
      font-weight: 700;
      font-size: 24px;
      text-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
    }
    
    .hud-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .hud-label {
      font-size: 12px;
      opacity: 0.6;
      letter-spacing: 2px;
    }
    
    .hud-value {
      font-size: 32px;
      color: #ff4757;
      text-shadow: 0 0 30px rgba(255, 71, 87, 0.8);
    }
    
    #environmentLabel {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 1s ease;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      text-transform: uppercase;
      font-weight: 700;
      z-index: 10;
    }
    
    #environmentLabel.show {
      opacity: 0.8;
    }
    
    #startScreen, #skinScreen, #gameOverScreen, #leaderboardScreen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: rgba(15, 15, 15, 0.95);
      z-index: 100;
      animation: fadeIn 0.3s ease;
      padding: max(20px, env(safe-area-inset-top)) 20px max(20px, env(safe-area-inset-bottom));
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }
    
    /* Center content vertically when there's enough space */
    #startScreen > *, #skinScreen > *, #gameOverScreen > *, #leaderboardScreen > * {
      flex-shrink: 0;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    h1 {
      font-family: 'Archivo Black', sans-serif;
      font-size: clamp(36px, 10vw, 72px);
      margin-bottom: 15px;
      margin-top: 20px;
      background: linear-gradient(135deg, #ff4757 0%, #ff6348 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: clamp(3px, 1.5vw, 8px);
      text-shadow: 0 0 60px rgba(255, 71, 87, 0.5);
      animation: titlePulse 2s ease-in-out infinite;
      text-align: center;
      line-height: 1.1;
    }
    
    @keyframes titlePulse {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.02); filter: brightness(1.2); }
    }
    
    .subtitle {
      font-size: clamp(14px, 3vw, 18px);
      opacity: 0.7;
      margin-bottom: 30px;
      letter-spacing: 2px;
      text-align: center;
      padding: 0 10px;
    }
    
    button {
      font-family: 'Space Mono', monospace;
      font-size: clamp(16px, 3.5vw, 20px);
      font-weight: 700;
      padding: clamp(15px, 3vw, 20px) clamp(30px, 8vw, 50px);
      background: linear-gradient(135deg, #ff4757 0%, #ff6348 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      letter-spacing: 2px;
      box-shadow: 
        0 10px 30px rgba(255, 71, 87, 0.5),
        0 0 50px rgba(255, 71, 87, 0.3);
      transition: all 0.3s ease;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      margin: 5px;
    }
    
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s ease;
    }
    
    button:hover::before {
      left: 100%;
    }
    
    button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 
        0 15px 40px rgba(255, 71, 87, 0.7),
        0 0 70px rgba(255, 71, 87, 0.5);
    }
    
    button:active {
      transform: translateY(-1px) scale(1.02);
    }
    
    /* Skin selection screen */
    #skinScreen h2 {
      font-family: 'Archivo Black', sans-serif;
      font-size: clamp(28px, 7vw, 48px);
      margin-bottom: 10px;
      margin-top: 10px;
      color: #ff4757;
      text-shadow: 0 0 40px rgba(255, 71, 87, 0.6);
      letter-spacing: clamp(2px, 0.8vw, 4px);
      text-align: center;
    }
    
    .skin-subtitle {
      font-size: clamp(12px, 3vw, 16px);
      opacity: 0.6;
      margin-bottom: 20px;
      letter-spacing: 1px;
      text-align: center;
      padding: 0 10px;
    }
    
    .skin-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: clamp(15px, 3vw, 25px);
      margin-bottom: 30px;
      max-width: 100%;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }
    
    @media (min-width: 500px) {
      .skin-grid {
        grid-template-columns: repeat(4, 1fr);
        max-width: 800px;
      }
    }
    
    .skin-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: clamp(10px, 3vw, 20px);
      border-radius: 15px;
      border: 2px solid transparent;
    }
    
    .skin-option:hover {
      transform: translateY(-5px);
      border-color: rgba(255, 71, 87, 0.3);
      background: rgba(255, 71, 87, 0.05);
    }
    
    .skin-option.selected {
      border-color: #ff4757;
      background: rgba(255, 71, 87, 0.1);
      box-shadow: 0 0 30px rgba(255, 71, 87, 0.4);
    }
    
    .skin-preview {
      width: clamp(60px, 15vw, 80px);
      height: clamp(60px, 15vw, 80px);
      border-radius: 50%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
    }
    
    .skin-option:hover .skin-preview {
      transform: scale(1.15);
      box-shadow: 0 15px 40px rgba(255, 71, 87, 0.5);
    }
    
    .skin-option.selected .skin-preview {
      transform: scale(1.2);
      box-shadow: 0 20px 50px rgba(255, 71, 87, 0.7);
    }
    
    .skin-name {
      font-size: clamp(11px, 2.5vw, 14px);
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.8;
      text-align: center;
    }
    
    .skin-option.selected .skin-name {
      color: #ff4757;
      opacity: 1;
    }
    
    #gameOverScreen h2 {
      font-family: 'Archivo Black', sans-serif;
      font-size: clamp(32px, 8vw, 48px);
      margin-bottom: 20px;
      margin-top: 10px;
      color: #ff4757;
      text-shadow: 0 0 40px rgba(255, 71, 87, 0.6);
      text-align: center;
    }
    
    .stats {
      display: flex;
      gap: clamp(20px, 8vw, 50px);
      margin-bottom: 30px;
      font-size: clamp(16px, 4vw, 24px);
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .stat {
      text-align: center;
    }
    
    .stat-value {
      font-size: clamp(32px, 8vw, 48px);
      color: #ff4757;
      font-weight: 700;
      text-shadow: 0 0 30px rgba(255, 71, 87, 0.6);
    }
    
    .stat-label {
      font-size: clamp(11px, 2.5vw, 14px);
      opacity: 0.6;
      letter-spacing: 2px;
      margin-top: 5px;
    }
    
    /* Leaderboard screen */
    #leaderboardScreen h2 {
      font-family: 'Archivo Black', sans-serif;
      font-size: clamp(28px, 7vw, 48px);
      margin-bottom: 10px;
      margin-top: 10px;
      color: #ff4757;
      text-shadow: 0 0 40px rgba(255, 71, 87, 0.6);
      letter-spacing: clamp(2px, 0.8vw, 4px);
      text-align: center;
    }
    
    .leaderboard-subtitle {
      font-size: clamp(12px, 3vw, 16px);
      opacity: 0.6;
      margin-bottom: 30px;
      letter-spacing: 2px;
    }
    
    #nameInput {
      font-family: 'Space Mono', monospace;
      font-size: clamp(16px, 4vw, 24px);
      padding: clamp(10px, 2vw, 15px) clamp(20px, 4vw, 30px);
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 71, 87, 0.5);
      border-radius: 10px;
      color: white;
      text-align: center;
      margin-bottom: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      max-width: 300px;
      width: 90%;
    }
    
    #nameInput:focus {
      outline: none;
      border-color: #ff4757;
      box-shadow: 0 0 30px rgba(255, 71, 87, 0.5);
    }
    
    .leaderboard-table {
      background: rgba(255, 255, 255, 0.02);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: clamp(15px, 4vw, 30px);
      margin-bottom: 20px;
      max-width: 500px;
      width: 95%;
    }
    
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      margin-bottom: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    
    .leaderboard-entry:hover {
      background: rgba(255, 71, 87, 0.1);
      transform: translateX(5px);
    }
    
    .leaderboard-entry.current-player {
      background: rgba(255, 71, 87, 0.2);
      border: 2px solid rgba(255, 71, 87, 0.5);
      box-shadow: 0 0 20px rgba(255, 71, 87, 0.3);
    }
    
    .leaderboard-rank {
      font-size: 24px;
      font-weight: 700;
      color: #ff4757;
      min-width: 40px;
    }
    
    .leaderboard-name {
      flex: 1;
      font-size: 18px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .leaderboard-score {
      font-size: 24px;
      font-weight: 700;
      color: #4fffb0;
      text-shadow: 0 0 20px rgba(79, 255, 176, 0.5);
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Power-up indicators */
    #powerupIndicators {
      position: absolute;
      top: 100px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
    }
    
    .powerup-indicator {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid;
      border-radius: 10px;
      padding: 10px 15px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 1px;
      animation: powerupGlow 1s ease-in-out infinite;
      min-width: 120px;
      text-align: center;
    }
    
    .powerup-indicator.freeze { border-color: #00ffff; color: #00ffff; }
    .powerup-indicator.shield { border-color: #00ff88; color: #00ff88; }
    .powerup-indicator.multiplier { border-color: #ff00ff; color: #ff00ff; }
    
    @keyframes powerupGlow {
      0%, 100% { box-shadow: 0 0 10px currentColor; }
      50% { box-shadow: 0 0 20px currentColor; }
    }
    
    /* Achievement popup */
    .achievement-popup {
      position: fixed;
      top: 20px;
      right: 20px;
      transform: translateX(0) scale(0);
      background: linear-gradient(135deg, #1a1a2e 0%, #2d2d44 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 20px 30px;
      z-index: 200;
      text-align: center;
      box-shadow: 0 0 100px rgba(255, 215, 0, 0.8);
      animation: achievementSlide 0.5s ease-out forwards;
      max-width: 300px;
      pointer-events: none;
    }
    
    @keyframes achievementSlide {
      0% { transform: translateX(400px) scale(0.8); opacity: 0; }
      100% { transform: translateX(0) scale(1); opacity: 1; }
    }
    
    .achievement-popup h3 {
      color: #ffd700;
      font-size: clamp(24px, 5vw, 32px);
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }
    
    .achievement-popup p {
      color: #fff;
      font-size: clamp(14px, 3vw, 18px);
      opacity: 0.9;
    }
    
    /* Combo feedback effects */
    .combo-milestone {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 50px rgba(255, 215, 0, 1);
      pointer-events: none;
      animation: comboMilestone 1s ease-out forwards;
      z-index: 150;
    }
    
    @keyframes comboMilestone {
      0% { transform: translate(-50%, -50%) scale(0) rotate(-20deg); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.5) rotate(10deg); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0; }
    }
    
    /* Screen shake effect */
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-5px, 5px); }
      20% { transform: translate(5px, -5px); }
      30% { transform: translate(-5px, -5px); }
      40% { transform: translate(5px, 5px); }
      50% { transform: translate(-5px, 5px); }
      60% { transform: translate(5px, -5px); }
      70% { transform: translate(-5px, -5px); }
      80% { transform: translate(5px, 5px); }
      90% { transform: translate(-5px, -5px); }
    }
    
    .screen-shake {
      animation: screenShake 0.3s ease-in-out;
    }
    
    /* Perfect click feedback */
    .perfect-click {
      position: absolute;
      color: #ffd700;
      font-weight: 900;
      font-size: 24px;
      pointer-events: none;
      animation: perfectFloat 1s ease-out forwards;
      text-shadow: 0 0 20px rgba(255, 215, 0, 1);
      z-index: 60;
    }
    
    @keyframes perfectFloat {
      0% { transform: translateY(0) scale(0.5); opacity: 1; }
      100% { transform: translateY(-100px) scale(1.5); opacity: 0; }
    }
    
    /* Particle effects */
    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 40;
    }
    
    @keyframes particleExplode {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    
    .ripple {
      position: absolute;
      border-radius: 50%;
      border: 3px solid rgba(255, 71, 87, 0.8);
      pointer-events: none;
      animation: rippleEffect 0.6s ease-out forwards;
    }
    
    @keyframes rippleEffect {
      0% {
        width: 0;
        height: 0;
        opacity: 1;
      }
      100% {
        width: 150px;
        height: 150px;
        opacity: 0;
      }
    }
    
    .score-popup {
      position: absolute;
      color: #4fffb0;
      font-weight: 700;
      font-size: 32px;
      pointer-events: none;
      animation: scoreFloat 1s ease-out forwards;
      text-shadow: 0 0 20px rgba(79, 255, 176, 0.8);
      z-index: 50;
    }
    
    @keyframes scoreFloat {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(-80px) scale(1.5);
        opacity: 0;
      }
    }
    
    /* Flexible spacer for centering content when space available */
    .flex-spacer {
      flex: 1;
      min-height: 0;
    }
      .skin-preview { width: 70px; height: 70px; }
      .leaderboard-table { padding: 20px; }
      .leaderboard-entry { padding: 10px 15px; }
    }
  </style>
</head>
<body>
  <div class="bg-stars" id="bgStars"></div>
  
  <div id="gameContainer">
    <div id="startScreen">
      <h1>TAP‚Ä¢DOT</h1>
      <div class="subtitle">JOURNEY THROUGH DIMENSIONS</div>
      <button onclick="showSkinSelection()">START GAME</button>
      <button onclick="showLeaderboard()" style="margin-top: 20px; background: linear-gradient(135deg, #4fffb0 0%, #06ffa5 100%);">VIEW LEADERBOARD</button>
    </div>
    
    <div id="skinScreen" class="hidden">
      <h2>CHOOSE YOUR SKIN</h2>
      <div class="skin-subtitle">Select your dot style ‚Ä¢ Click to preview sound</div>
      
      <div class="skin-grid">
        <div class="skin-option selected" onclick="selectSkin('classic')">
          <div class="skin-preview skin-classic"></div>
          <div class="skin-name">Classic</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('leopard')">
          <div class="skin-preview skin-leopard"></div>
          <div class="skin-name">Leopard</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('military')">
          <div class="skin-preview skin-military"></div>
          <div class="skin-name">Military</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('tiger')">
          <div class="skin-preview skin-tiger"></div>
          <div class="skin-name">Tiger</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('zebra')">
          <div class="skin-preview skin-zebra"></div>
          <div class="skin-name">Zebra</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('neon')">
          <div class="skin-preview skin-neon"></div>
          <div class="skin-name">Neon</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('galaxy')">
          <div class="skin-preview skin-galaxy"></div>
          <div class="skin-name">Galaxy</div>
        </div>
        
        <div class="skin-option" onclick="selectSkin('lava')">
          <div class="skin-preview skin-lava"></div>
          <div class="skin-name">Lava</div>
        </div>
      </div>
      
      <button onclick="startGame()">PLAY NOW</button>
    </div>
    
    <div id="hud" class="hidden">
      <div class="hud-item">
        <div class="hud-label">SCORE</div>
        <div class="hud-value" id="score">0</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">COMBO</div>
        <div class="hud-value" id="combo">0</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">BEST</div>
        <div class="hud-value" id="highScore">0</div>
      </div>
    </div>
    
    <div id="environmentLabel" class="hidden"></div>
    
    <div id="powerupIndicators"></div>
    
    <div id="gameArea"></div>
    
    <div id="gameOverScreen" class="hidden">
      <h2>GAME OVER</h2>
      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="finalScore">0</div>
          <div class="stat-label">FINAL SCORE</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="finalCombo">0</div>
          <div class="stat-label">MAX COMBO</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="finalAccuracy">0%</div>
          <div class="stat-label">ACCURACY</div>
        </div>
      </div>
      <button onclick="checkLeaderboard()">CONTINUE</button>
    </div>
    
    <div id="leaderboardScreen" class="hidden">
      <h2 id="leaderboardTitle">TOP 10 PLAYERS</h2>
      <div class="leaderboard-subtitle" id="leaderboardSubtitle"></div>
      <div id="nameInputContainer" class="hidden">
        <input type="text" id="nameInput" placeholder="ENTER YOUR NAME" maxlength="12">
        <button onclick="saveScore()" style="display: block; margin: 0 auto;">SAVE SCORE</button>
      </div>
      <div class="leaderboard-table" id="leaderboardTable"></div>
      <button onclick="backToMenu()">BACK TO MENU</button>
    </div>
  </div>

  <script>
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let highScore = localStorage.getItem('highScore') || 0;
    let currentDot = null;
    let gameActive = false;
    let dotTimeout = null;
    let selectedSkin = 'classic';
    let gameStartTime = null;
    let currentEnvironment = 0;
    let enemyDots = []; // Track enemy dots
    let dotsClicked = 0; // Track total dots clicked for progression
    let currentDotSpawnTime = null; // Track when dot spawned for point decay
    let currentDotMaxPoints = 0; // Max points for current dot
    
    // Power-ups
    let activePowerups = {
      freeze: false,
      shield: false,
      multiplier: false,
      magnet: false
    };
    let powerupTimeouts = {};
    
    // Stats tracking
    let perfectClicks = 0; // Clicks within first 20% of lifetime
    let enemiesAvoided = 0;
    let totalAccuracy = [];
    
    // Achievements
    let achievements = JSON.parse(localStorage.getItem('achievements') || '{}');
    const achievementList = {
      speedDemon: { name: 'Speed Demon', desc: 'Click 10 dots in 5 seconds', unlocked: false },
      perfectStreak: { name: 'Perfect Streak', desc: 'Get 20 dots with 90%+ points each', unlocked: false },
      enemyHunter: { name: 'Enemy Hunter', desc: 'Avoid 50 enemy dots in one game', unlocked: false },
      marathonMaster: { name: 'Marathon Master', desc: 'Survive 2 minutes', unlocked: false },
      comboKing: { name: 'Combo King', desc: 'Reach 50 combo', unlocked: false },
      sharpshooter: { name: 'Sharpshooter', desc: '10 perfect clicks in a row', unlocked: false },
      survivor: { name: 'Survivor', desc: 'Reach 5000 points', unlocked: false },
      legend: { name: 'Legend', desc: 'Reach 10000 points', unlocked: false }
    };
    
    // Daily challenge
    let dailyChallenge = localStorage.getItem('dailyChallenge') || 'normal';
    let dailyChallengeDate = localStorage.getItem('dailyChallengeDate') || '';
    
    // Speed tracking for Speed Demon achievement
    let recentClickTimes = [];
    
    const gameArea = document.getElementById('gameArea');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const highScoreEl = document.getElementById('highScore');
    const startScreen = document.getElementById('startScreen');
    const skinScreen = document.getElementById('skinScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const leaderboardScreen = document.getElementById('leaderboardScreen');
    const hud = document.getElementById('hud');
    const environmentLabel = document.getElementById('environmentLabel');
    
    highScoreEl.textContent = highScore;
    
    // Environments that change as you progress
    const environments = [
      { name: 'DEEP SPACE', class: 'bg-space', duration: 8 },
      { name: 'NEON CITY', class: 'bg-neon', duration: 6 },
      { name: 'CYBERPUNK STREETS', class: 'bg-cyber', duration: 6 },
      { name: 'ELECTRIC DISTRICT', class: 'bg-electric', duration: 6 },
      { name: 'COSMIC GALAXY', class: 'bg-galaxy', duration: 6 },
      { name: 'NEON UNDERGROUND', class: 'bg-neon-street', duration: 6 },
      { name: 'CYBER RAIN', class: 'bg-cyber-rain', duration: 6 },
      { name: 'UNDERWATER RUINS', class: 'bg-underwater', duration: 6 },
      { name: 'DEEP OCEAN', class: 'bg-deep-ocean', duration: 6 },
      { name: 'LOST ATLANTIS', class: 'bg-abyss', duration: 6 },
      { name: 'LAVA REALM', class: 'bg-lava', duration: 6 },
      { name: 'DIGITAL VOID', class: 'bg-void', duration: 6 },
      { name: 'NEON MATRIX', class: 'bg-electric', duration: 6 },
      { name: 'CYBER ABYSS', class: 'bg-cyber', duration: 6 },
      { name: 'THE VOID', class: 'bg-void', duration: 999 }
    ];
    
    // Generate background stars
    function generateStars() {
      const container = document.getElementById('bgStars');
      container.innerHTML = '';
      for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        container.appendChild(star);
      }
    }
    
    generateStars();
    
    // Generate animated background effects
    function updateBackgroundEffects() {
      const bgContainer = document.getElementById('bgStars');
      const currentClass = document.body.className;
      
      // Clear existing effects
      bgContainer.innerHTML = '';
      bgContainer.className = 'bg-stars';
      
      if (currentClass.includes('space') || currentClass.includes('galaxy') || currentClass.includes('void')) {
        // Generate stars
        for (let i = 0; i < 150; i++) {
          const star = document.createElement('div');
          star.className = 'star';
          star.style.left = Math.random() * 100 + '%';
          star.style.top = Math.random() * 100 + '%';
          star.style.animationDelay = Math.random() * 3 + 's';
          star.style.width = (Math.random() * 2 + 1) + 'px';
          star.style.height = star.style.width;
          bgContainer.appendChild(star);
        }
      } else if (currentClass.includes('cyber') || currentClass.includes('neon')) {
        // Cyber rain effect
        bgContainer.className = 'cyber-rain';
        for (let i = 0; i < 30; i++) {
          const drop = document.createElement('div');
          drop.className = 'rain-drop';
          drop.style.left = Math.random() * 100 + '%';
          drop.style.animationDuration = (Math.random() * 2 + 1) + 's';
          drop.style.animationDelay = Math.random() * 2 + 's';
          bgContainer.appendChild(drop);
        }
        
        // Add neon grid
        const grid = document.createElement('div');
        grid.className = 'neon-grid';
        bgContainer.appendChild(grid);
      } else if (currentClass.includes('underwater') || currentClass.includes('abyss') || currentClass.includes('ocean')) {
        // Underwater bubbles
        bgContainer.className = 'underwater-bubbles';
        for (let i = 0; i < 25; i++) {
          const bubble = document.createElement('div');
          bubble.className = 'bubble';
          const size = Math.random() * 30 + 10;
          bubble.style.width = size + 'px';
          bubble.style.height = size + 'px';
          bubble.style.left = Math.random() * 100 + '%';
          bubble.style.bottom = '-50px';
          bubble.style.setProperty('--drift', (Math.random() * 100 - 50) + 'px');
          bubble.style.animationDuration = (Math.random() * 10 + 8) + 's';
          bubble.style.animationDelay = Math.random() * 5 + 's';
          bgContainer.appendChild(bubble);
        }
      } else if (currentClass.includes('lava')) {
        // Lava particles
        bgContainer.className = 'lava-particles';
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'lava-particle';
          const size = Math.random() * 40 + 20;
          particle.style.width = size + 'px';
          particle.style.height = size + 'px';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.top = Math.random() * 100 + '%';
          particle.style.animationDuration = (Math.random() * 3 + 2) + 's';
          particle.style.animationDelay = Math.random() * 2 + 's';
          bgContainer.appendChild(particle);
        }
      }
    }
    
    // Power-up functions
    function activatePowerup(type, duration) {
      if (activePowerups[type]) return; // Already active
      
      activePowerups[type] = true;
      playPowerupSound(); // Play sound on activation
      
      // Show indicator
      const indicator = document.createElement('div');
      indicator.className = `powerup-indicator ${type}`;
      indicator.id = `powerup-${type}`;
      
      const names = {
        freeze: '‚ùÑÔ∏è FREEZE',
        shield: 'üõ°Ô∏è SHIELD',
        multiplier: '‚ú® 2X POINTS'
      };
      
      indicator.textContent = names[type];
      document.getElementById('powerupIndicators').appendChild(indicator);
      
      // Apply effects
      if (type === 'freeze') {
        // Slow down all dots
        if (currentDot) {
          const currentDuration = parseFloat(currentDot.style.animationDuration);
          currentDot.style.animationDuration = (currentDuration * 2) + 'ms';
        }
        enemyDots.forEach(dot => {
          const currentDuration = parseFloat(dot.style.animationDuration);
          dot.style.animationDuration = (currentDuration * 2) + 'ms';
        });
      }
      
      // Remove after duration
      powerupTimeouts[type] = setTimeout(() => {
        deactivatePowerup(type);
      }, duration);
    }
    
    function deactivatePowerup(type) {
      activePowerups[type] = false;
      const indicator = document.getElementById(`powerup-${type}`);
      if (indicator) indicator.remove();
      if (powerupTimeouts[type]) {
        clearTimeout(powerupTimeouts[type]);
        delete powerupTimeouts[type];
      }
    }
    
    // Achievement system
    function checkAchievements() {
      // Speed Demon - 10 dots in 5 seconds
      if (recentClickTimes.length >= 10) {
        const timeSpan = Date.now() - recentClickTimes[0];
        if (timeSpan <= 5000) {
          unlockAchievement('speedDemon');
        }
      }
      
      // Perfect Streak - 20 dots with 90%+ accuracy
      if (totalAccuracy.length >= 20) {
        const recent20 = totalAccuracy.slice(-20);
        const allPerfect = recent20.every(acc => acc >= 0.9);
        if (allPerfect) {
          unlockAchievement('perfectStreak');
        }
      }
      
      // Enemy Hunter
      if (enemiesAvoided >= 50) {
        unlockAchievement('enemyHunter');
      }
      
      // Marathon Master - 2 minutes
      if (gameActive && (Date.now() - gameStartTime) >= 120000) {
        unlockAchievement('marathonMaster');
      }
      
      // Combo King
      if (combo >= 50) {
        unlockAchievement('comboKing');
      }
      
      // Sharpshooter - 10 perfect clicks in a row
      if (perfectClicks >= 10) {
        unlockAchievement('sharpshooter');
      }
      
      // Score milestones
      if (score >= 5000) unlockAchievement('survivor');
      if (score >= 10000) unlockAchievement('legend');
    }
    
    function unlockAchievement(id) {
      if (achievements[id]) return; // Already unlocked
      
      achievements[id] = true;
      localStorage.setItem('achievements', JSON.stringify(achievements));
      
      // Play achievement sound
      playAchievementSound();
      
      // Show popup that doesn't block gameplay
      const popup = document.createElement('div');
      popup.className = 'achievement-popup';
      popup.innerHTML = `
        <h3>üèÜ ACHIEVEMENT UNLOCKED!</h3>
        <p><strong>${achievementList[id].name}</strong></p>
        <p>${achievementList[id].desc}</p>
      `;
      document.body.appendChild(popup);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transition = 'opacity 0.5s ease';
        setTimeout(() => popup.remove(), 500);
      }, 2500);
    }
    
    // Combo visual effects
    function triggerComboEffect() {
      if (combo === 10 || combo === 25 || combo === 50 || combo === 100) {
        // Screen shake
        gameArea.classList.add('screen-shake');
        setTimeout(() => gameArea.classList.remove('screen-shake'), 300);
        
        // Milestone text
        const milestone = document.createElement('div');
        milestone.className = 'combo-milestone';
        milestone.textContent = combo + ' COMBO!';
        gameArea.appendChild(milestone);
        setTimeout(() => milestone.remove(), 1000);
        
        // Particle explosion
        createParticleExplosion(
          gameArea.offsetWidth / 2,
          gameArea.offsetHeight / 2,
          combo >= 50 ? '#ffd700' : '#ff4757'
        );
      }
      
      // Change combo color based on level
      const comboEl = document.getElementById('combo');
      if (combo >= 50) {
        comboEl.style.color = '#ffd700';
      } else if (combo >= 25) {
        comboEl.style.color = '#ff6348';
      } else if (combo >= 10) {
        comboEl.style.color = '#ff8c00';
      } else {
        comboEl.style.color = '#4fffb0';
      }
    }
    
    function createParticleExplosion(x, y, color) {
      const particleCount = 20;
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = color;
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 100 + Math.random() * 100;
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        
        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');
        particle.style.animation = 'particleExplode 1s ease-out forwards';
        
        gameArea.appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      }
    }
    
    // Audio Context for generating sounds - initialize but will be unlocked on first interaction
    let audioCtx;
    let audioUnlocked = false;
    
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.log('Audio not supported');
    }
    
    // Unlock audio on iOS - must be called from user interaction
    function unlockAudio() {
      if (!audioCtx || audioUnlocked) return;
      
      // Resume the audio context
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      
      // Create and play a silent buffer to unlock audio
      const buffer = audioCtx.createBuffer(1, 1, 22050);
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start(0);
      
      audioUnlocked = true;
    }
    
    // Attach unlock to first user interaction
    document.addEventListener('touchstart', unlockAudio, { once: true });
    document.addEventListener('touchend', unlockAudio, { once: true });
    document.addEventListener('click', unlockAudio, { once: true });
    
    // Sound generators for each skin
    const sounds = {
      classic: () => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.08);
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.08);
      },
      leopard: () => {
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        osc1.frequency.setValueAtTime(180, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.12);
        osc2.frequency.setValueAtTime(185, audioCtx.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(85, audioCtx.currentTime + 0.12);
        osc1.type = 'sawtooth';
        osc2.type = 'square';
        gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
        osc1.start(audioCtx.currentTime);
        osc2.start(audioCtx.currentTime);
        osc1.stop(audioCtx.currentTime + 0.12);
        osc2.stop(audioCtx.currentTime + 0.12);
      },
      military: () => {
        const noise = audioCtx.createBufferSource();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        const bufferSize = audioCtx.sampleRate * 0.06;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 3));
        }
        noise.buffer = buffer;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'highpass';
        filter.frequency.value = 200;
        gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.06);
        noise.start(audioCtx.currentTime);
        noise.stop(audioCtx.currentTime + 0.06);
      },
      tiger: () => {
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, audioCtx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
        osc1.frequency.setValueAtTime(220, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(90, audioCtx.currentTime + 0.15);
        osc2.frequency.setValueAtTime(227, audioCtx.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(95, audioCtx.currentTime + 0.15);
        osc1.type = 'sawtooth';
        osc2.type = 'square';
        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc1.start(audioCtx.currentTime);
        osc2.start(audioCtx.currentTime);
        osc1.stop(audioCtx.currentTime + 0.15);
        osc2.stop(audioCtx.currentTime + 0.15);
      },
      zebra: () => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'bandpass';
        filter.frequency.value = 1800;
        filter.Q.value = 5;
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.08);
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.08);
      },
      neon: () => {
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 3;
        osc1.frequency.setValueAtTime(1200, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(2400, audioCtx.currentTime + 0.08);
        osc2.frequency.setValueAtTime(1800, audioCtx.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(3600, audioCtx.currentTime + 0.08);
        osc1.type = 'square';
        osc2.type = 'sine';
        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
        osc1.start(audioCtx.currentTime);
        osc2.start(audioCtx.currentTime);
        osc1.stop(audioCtx.currentTime + 0.08);
        osc2.stop(audioCtx.currentTime + 0.08);
      },
      galaxy: () => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, audioCtx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.18);
        filter.Q.value = 8;
        osc.frequency.setValueAtTime(2000, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.18);
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.18);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.18);
      },
      lava: () => {
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const noise = audioCtx.createBufferSource();
        const gain = audioCtx.createGain();
        const noiseGain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        const bufferSize = audioCtx.sampleRate * 0.12;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.sin(i / 100);
        }
        noise.buffer = buffer;
        osc1.connect(filter);
        osc2.connect(filter);
        noise.connect(noiseGain);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noiseGain.connect(audioCtx.destination);
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        osc1.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(120, audioCtx.currentTime + 0.12);
        osc2.frequency.setValueAtTime(450, audioCtx.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(180, audioCtx.currentTime + 0.12);
        osc1.type = 'triangle';
        osc2.type = 'sawtooth';
        gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
        noiseGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
        osc1.start(audioCtx.currentTime);
        osc2.start(audioCtx.currentTime);
        noise.start(audioCtx.currentTime);
        osc1.stop(audioCtx.currentTime + 0.12);
        osc2.stop(audioCtx.currentTime + 0.12);
        noise.stop(audioCtx.currentTime + 0.12);
      }
    };
    
    function playSound(skinName) {
      if (!audioCtx || !sounds[skinName]) return;
      
      // Resume audio context if suspended (iOS requirement)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      
      try {
        sounds[skinName]();
      } catch (e) {
        console.log('Audio playback error:', e);
      }
    }
    
    // Power-up sound effect
    function playPowerupSound() {
      if (!audioCtx) return;
      try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
        osc.frequency.exponentialRampToValueAtTime(783.99, audioCtx.currentTime + 0.1); // G5
        osc.frequency.exponentialRampToValueAtTime(1046.50, audioCtx.currentTime + 0.2); // C6
        
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.3);
      } catch (e) {
        console.log('Powerup sound error:', e);
      }
    }
    
    // Achievement sound effect
    function playAchievementSound() {
      if (!audioCtx) return;
      try {
        // Triumphant fanfare
        const times = [0, 0.15, 0.3];
        const freqs = [523.25, 659.25, 783.99]; // C-E-G chord
        
        times.forEach((time, i) => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          
          osc.frequency.setValueAtTime(freqs[i], audioCtx.currentTime + time);
          osc.type = 'triangle';
          gain.gain.setValueAtTime(0.2, audioCtx.currentTime + time);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + time + 0.5);
          
          osc.start(audioCtx.currentTime + time);
          osc.stop(audioCtx.currentTime + time + 0.5);
        });
      } catch (e) {
        console.log('Achievement sound error:', e);
      }
    }
    
    // Perfect click sound
    function playPerfectSound() {
      if (!audioCtx) return;
      try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.frequency.setValueAtTime(1046.50, audioCtx.currentTime); // C6
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.1);
      } catch (e) {
        console.log('Perfect sound error:', e);
      }
    }
    
    function showSkinSelection() {
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      leaderboardScreen.classList.add('hidden');
      skinScreen.classList.remove('hidden');
    }
    
    function selectSkin(skinName) {
      selectedSkin = skinName;
      playSound(skinName);
      document.querySelectorAll('.skin-option').forEach(option => {
        option.classList.remove('selected');
      });
      event.currentTarget.classList.add('selected');
    }
    
    function updateEnvironment() {
      if (!gameActive) return;
      
      const elapsed = (Date.now() - gameStartTime) / 1000;
      let totalTime = 0;
      let newEnv = 0;
      
      for (let i = 0; i < environments.length; i++) {
        totalTime += environments[i].duration;
        if (elapsed < totalTime) {
          newEnv = i;
          break;
        }
      }
      
      if (newEnv !== currentEnvironment) {
        currentEnvironment = newEnv;
        document.body.className = environments[currentEnvironment].class;
        updateBackgroundEffects(); // Update animated backgrounds
        environmentLabel.textContent = environments[currentEnvironment].name;
        environmentLabel.classList.add('show');
        setTimeout(() => {
          environmentLabel.classList.remove('show');
        }, 3000);
      }
    }
    
    function startGame() {
      // Unlock audio on game start (iOS requirement)
      unlockAudio();
      
      score = 0;
      combo = 0;
      maxCombo = 0;
      gameActive = true;
      gameStartTime = Date.now();
      currentEnvironment = 0;
      dotsClicked = 0;
      enemyDots = [];
      currentDotSpawnTime = null;
      currentDotMaxPoints = 0;
      perfectClicks = 0;
      enemiesAvoided = 0;
      totalAccuracy = [];
      recentClickTimes = [];
      
      // Clear power-ups
      Object.keys(activePowerups).forEach(key => {
        deactivatePowerup(key);
      });
      document.getElementById('powerupIndicators').innerHTML = '';
      
      scoreEl.textContent = score;
      comboEl.textContent = combo;
      
      skinScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      hud.classList.remove('hidden');
      environmentLabel.classList.remove('hidden');
      gameArea.classList.add('active');
      
      document.body.className = environments[0].class;
      updateBackgroundEffects(); // Initialize animated backgrounds
      environmentLabel.textContent = environments[0].name;
      environmentLabel.classList.add('show');
      setTimeout(() => {
        environmentLabel.classList.remove('show');
      }, 3000);
      
      spawnDot();
    }
    
    function calculateDotLifetime() {
      // Start with 2.5 seconds, rapidly decrease to 0.5 seconds
      // Reach minimum after only 50 dots for intense difficulty
      const baseTime = 2500; // 2.5 seconds
      const minTime = 500; // 0.5 second minimum - very fast!
      const maxDots = 50; // Reach minimum much faster
      
      // Aggressive exponential curve for rapid difficulty increase
      const progress = Math.min(dotsClicked / maxDots, 1);
      const exponentialProgress = Math.pow(progress, 0.7); // Makes it harder faster
      const timeReduction = (baseTime - minTime) * exponentialProgress;
      
      return baseTime - timeReduction;
    }
    
    function spawnDot() {
      if (!gameActive) return;
      
      updateEnvironment();
      
      // Clear any existing timeout
      if (dotTimeout) {
        clearTimeout(dotTimeout);
        dotTimeout = null;
      }
      
      if (currentDot) {
        currentDot.remove();
        currentDot = null;
      }
      
      // Determine dot type - regular, power-up, or both
      const powerupTypes = ['gold', 'freeze', 'shield', 'multiplier'];
      let dotType = 'regular';
      let powerupType = null;
      
      // Power-ups have small spawn chances
      if (dotsClicked >= 5) {
        const rand = Math.random();
        if (rand < 0.08) { // 8% for gold
          dotType = 'powerup';
          powerupType = 'gold';
        } else if (rand < 0.13) { // 5% for freeze
          dotType = 'powerup';
          powerupType = 'freeze';
        } else if (rand < 0.18) { // 5% for shield
          dotType = 'powerup';
          powerupType = 'shield';
        } else if (rand < 0.23) { // 5% for multiplier
          dotType = 'powerup';
          powerupType = 'multiplier';
        }
      }
      
      // Always spawn a regular or powerup dot
      const dot = document.createElement('div');
      dot.className = `dot skin-${selectedSkin}`;
      
      if (dotType === 'powerup') {
        dot.classList.add(`powerup-${powerupType}`);
        dot.dataset.powerup = powerupType;
      }
      
      const areaRect = gameArea.getBoundingClientRect();
      const dotSize = 60;
      const maxX = areaRect.width - dotSize;
      const maxY = areaRect.height - dotSize;
      
      const x = Math.random() * maxX;
      const y = Math.random() * maxY;
      
      dot.style.left = x + 'px';
      dot.style.top = y + 'px';
      
      let dotLifetime = calculateDotLifetime();
      
      // Apply freeze effect if active
      if (activePowerups.freeze) {
        dotLifetime *= 2;
      }
      
      dot.style.animationDuration = dotLifetime + 'ms';
      dot.classList.add('shrinking');
      
      // Set up point decay for regular dot
      const comboMultiplier = Math.floor(combo / 5) + 1;
      currentDotMaxPoints = 150 * comboMultiplier; // Increased from 100 to 150 for more reward
      currentDotSpawnTime = Date.now();
      
      dot.addEventListener('click', (e) => onDotClick(e, false));
      
      gameArea.appendChild(dot);
      currentDot = dot;
      
      // Set game-ending timeout for regular dot
      dotTimeout = setTimeout(() => {
        if (!gameActive) return;
        gameOver();
      }, dotLifetime);
      
      // Occasionally spawn an enemy dot ALONGSIDE the regular dot
      // Start after only 10 dots, increase frequency as game progresses
      if (dotsClicked >= 10) {
        const enemyChance = Math.min(0.15 + (dotsClicked / 200), 0.35); // 15% to 35% chance
        if (Math.random() < enemyChance) {
          setTimeout(() => {
            if (gameActive) spawnEnemyDot();
          }, 100); // Small delay to ensure regular dot is placed first
        }
      }
    }
    
    function spawnEnemyDot() {
      if (!gameActive) return;
      
      const enemyDot = document.createElement('div');
      enemyDot.className = `dot skin-${selectedSkin} enemy`;
      enemyDot.dataset.isEnemy = 'true';
      
      const areaRect = gameArea.getBoundingClientRect();
      const dotSize = 60;
      const maxX = areaRect.width - dotSize;
      const maxY = areaRect.height - dotSize;
      
      // Make sure enemy doesn't spawn too close to the regular dot
      let x, y, validPosition;
      let attempts = 0;
      
      do {
        x = Math.random() * maxX;
        y = Math.random() * maxY;
        validPosition = true;
        
        // Check distance from regular dot
        if (currentDot) {
          const currentX = parseFloat(currentDot.style.left);
          const currentY = parseFloat(currentDot.style.top);
          const distance = Math.sqrt(Math.pow(x - currentX, 2) + Math.pow(y - currentY, 2));
          if (distance < 120) { // Minimum 120px apart
            validPosition = false;
          }
        }
        
        // Check distance from other enemy dots
        for (let enemy of enemyDots) {
          if (enemy.parentNode) {
            const enemyX = parseFloat(enemy.style.left);
            const enemyY = parseFloat(enemy.style.top);
            const distance = Math.sqrt(Math.pow(x - enemyX, 2) + Math.pow(y - enemyY, 2));
            if (distance < 120) {
              validPosition = false;
              break;
            }
          }
        }
        
        attempts++;
      } while (!validPosition && attempts < 20);
      
      // If we couldn't find a valid position, just place it randomly
      if (!validPosition) {
        x = Math.random() * maxX;
        y = Math.random() * maxY;
      }
      
      enemyDot.style.left = x + 'px';
      enemyDot.style.top = y + 'px';
      
      // Enemy dots last slightly longer than regular dots
      const dotLifetime = calculateDotLifetime() * 1.3;
      enemyDot.style.animationDuration = dotLifetime + 'ms';
      enemyDot.classList.add('shrinking');
      
      enemyDot.addEventListener('click', (e) => onDotClick(e, true));
      
      gameArea.appendChild(enemyDot);
      enemyDots.push(enemyDot);
      
      // Remove enemy dot after its lifetime
      setTimeout(() => {
        if (!gameActive) return;
        const index = enemyDots.indexOf(enemyDot);
        if (index > -1) {
          enemyDots.splice(index, 1);
          enemiesAvoided++; // Track for achievement
        }
        if (enemyDot.parentNode) enemyDot.remove();
      }, dotLifetime);
    }
    
    function onDotClick(e, isEnemy) {
      if (!gameActive) return;
      
      e.stopPropagation();
      
      const clickedDot = e.currentTarget;
      
      if (isEnemy) {
        // Check if shield is active
        if (activePowerups.shield) {
          // Shield blocks the damage!
          deactivatePowerup('shield');
          
          const rect = clickedDot.getBoundingClientRect();
          const areaRect = gameArea.getBoundingClientRect();
          const popup = document.createElement('div');
          popup.className = 'perfect-click';
          popup.textContent = 'üõ°Ô∏è BLOCKED!';
          popup.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
          popup.style.top = (rect.top - areaRect.top + rect.height / 2 - 30) + 'px';
          gameArea.appendChild(popup);
          setTimeout(() => popup.remove(), 1000);
          
          const index = enemyDots.indexOf(clickedDot);
          if (index > -1) enemyDots.splice(index, 1);
          clickedDot.remove();
          return;
        }
        
        // Enemy dot clicked - harsh penalty
        playSound('military');
        
        const penalty = 100; // Increased from 50 to 100
        score = Math.max(0, score - penalty);
        combo = 0; // Reset combo
        perfectClicks = 0;
        
        scoreEl.textContent = score;
        comboEl.textContent = combo;
        
        // Show penalty popup
        const rect = clickedDot.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const popup = document.createElement('div');
        popup.className = 'score-popup';
        popup.style.color = '#ff0000';
        popup.textContent = '-' + penalty;
        popup.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
        popup.style.top = (rect.top - areaRect.top + rect.height / 2 - 30) + 'px';
        gameArea.appendChild(popup);
        
        setTimeout(() => popup.remove(), 1000);
        
        // Remove enemy dot
        const index = enemyDots.indexOf(clickedDot);
        if (index > -1) enemyDots.splice(index, 1);
        clickedDot.remove();
        
        return;
      }
      
      // Regular dot clicked - clear timeout and spawn next
      if (dotTimeout) {
        clearTimeout(dotTimeout);
        dotTimeout = null;
      }
      
      // Check for power-up
      const powerupType = clickedDot.dataset.powerup;
      if (powerupType) {
        if (powerupType === 'gold') {
          currentDotMaxPoints *= 3;
        } else {
          activatePowerup(powerupType, 5000);
        }
      }
      
      playSound(selectedSkin);
      
      // Calculate points based on reaction time with aggressive decay
      const clickTime = Date.now();
      const timeElapsed = clickTime - currentDotSpawnTime;
      const dotLifetime = calculateDotLifetime();
      const timeRatio = Math.max(0, 1 - (timeElapsed / dotLifetime));
      
      // More aggressive point decay - drops to 5% instead of 10%
      const minPointsRatio = 0.05;
      const pointsRatio = minPointsRatio + (1 - minPointsRatio) * Math.pow(timeRatio, 1.5);
      let earnedPoints = Math.ceil(currentDotMaxPoints * pointsRatio);
      
      // Apply multiplier if active
      if (activePowerups.multiplier) {
        earnedPoints *= 2;
      }
      
      // Check for perfect click (within first 20%)
      const isPerfect = timeRatio >= 0.8;
      if (isPerfect) {
        earnedPoints = Math.ceil(earnedPoints * 1.2);
        perfectClicks++;
        playPerfectSound(); // Play perfect sound
        
        const rect = clickedDot.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const perfectPopup = document.createElement('div');
        perfectPopup.className = 'perfect-click';
        perfectPopup.textContent = 'PERFECT!';
        perfectPopup.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
        perfectPopup.style.top = (rect.top - areaRect.top + rect.height / 2 - 50) + 'px';
        gameArea.appendChild(perfectPopup);
        setTimeout(() => perfectPopup.remove(), 1000);
      } else {
        perfectClicks = 0;
      }
      
      // Track accuracy
      totalAccuracy.push(pointsRatio);
      
      combo++;
      maxCombo = Math.max(maxCombo, combo);
      dotsClicked++;
      score += earnedPoints;
      
      // Track for Speed Demon achievement
      recentClickTimes.push(Date.now());
      if (recentClickTimes.length > 10) recentClickTimes.shift();
      
      scoreEl.textContent = score;
      comboEl.textContent = combo;
      
      // Trigger combo effects
      triggerComboEffect();
      checkAchievements();
      
      const rect = clickedDot.getBoundingClientRect();
      const areaRect = gameArea.getBoundingClientRect();
      
      // Ripple effect
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
      ripple.style.top = (rect.top - areaRect.top + rect.height / 2) + 'px';
      gameArea.appendChild(ripple);
      setTimeout(() => ripple.remove(), 600);
      
      // Score popup
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = '+' + earnedPoints;
      if (powerupType === 'gold') {
        popup.style.color = '#ffd700';
      }
      popup.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
      popup.style.top = (rect.top - areaRect.top + rect.height / 2 - 30) + 'px';
      gameArea.appendChild(popup);
      setTimeout(() => popup.remove(), 1000);
      
      // Particle burst on high combo
      if (combo >= 10) {
        createParticleExplosion(
          rect.left - areaRect.left + rect.width / 2,
          rect.top - areaRect.top + rect.height / 2,
          combo >= 25 ? '#ffd700' : '#4fffb0'
        );
      }
      
      clickedDot.remove();
      currentDot = null;
      
      // Always spawn next dot with minimal delay
      setTimeout(() => {
        if (gameActive) spawnDot();
      }, 150); // Reduced from 200ms to 150ms for faster pace
    }
    
    function gameOver() {
      gameActive = false;
      clearTimeout(dotTimeout);
      
      if (currentDot) {
        currentDot.remove();
        currentDot = null;
      }
      
      // Remove all enemy dots and power-ups
      enemyDots.forEach(dot => dot.remove());
      enemyDots = [];
      Object.keys(activePowerups).forEach(key => deactivatePowerup(key));
      
      gameArea.classList.remove('active');
      environmentLabel.classList.add('hidden');
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
        highScoreEl.textContent = highScore;
      }
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalCombo').textContent = maxCombo;
      
      // Calculate and display accuracy
      const avgAccuracy = totalAccuracy.length > 0
        ? Math.round((totalAccuracy.reduce((a, b) => a + b, 0) / totalAccuracy.length) * 100)
        : 0;
      document.getElementById('finalAccuracy').textContent = avgAccuracy + '%';
      
      gameOverScreen.classList.remove('hidden');
    }
    
    // Leaderboard functions
    function getLeaderboard() {
      const data = localStorage.getItem('leaderboard');
      return data ? JSON.parse(data) : [];
    }
    
    function saveLeaderboard(board) {
      localStorage.setItem('leaderboard', JSON.stringify(board));
    }
    
    function checkLeaderboard() {
      const board = getLeaderboard();
      const isTopTen = board.length < 10 || score > board[board.length - 1].score;
      
      if (isTopTen) {
        gameOverScreen.classList.add('hidden');
        leaderboardScreen.classList.remove('hidden');
        document.getElementById('leaderboardTitle').textContent = 'TOP 10!';
        document.getElementById('leaderboardSubtitle').textContent = 'You made it to the leaderboard!';
        document.getElementById('nameInputContainer').classList.remove('hidden');
        document.getElementById('nameInput').value = '';
        document.getElementById('nameInput').focus();
        displayLeaderboard(true);
      } else {
        showLeaderboard();
      }
    }
    
    function saveScore() {
      const name = document.getElementById('nameInput').value.trim().toUpperCase();
      if (!name) {
        alert('Please enter your name!');
        return;
      }
      
      const board = getLeaderboard();
      board.push({ name: name, score: score, date: Date.now() });
      board.sort((a, b) => b.score - a.score);
      if (board.length > 10) board.splice(10);
      saveLeaderboard(board);
      
      document.getElementById('nameInputContainer').classList.add('hidden');
      document.getElementById('leaderboardTitle').textContent = 'LEADERBOARD UPDATED!';
      document.getElementById('leaderboardSubtitle').textContent = 'Congratulations!';
      displayLeaderboard(false);
    }
    
    function showLeaderboard() {
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      leaderboardScreen.classList.remove('hidden');
      document.getElementById('leaderboardTitle').textContent = 'TOP 10 PLAYERS';
      document.getElementById('leaderboardSubtitle').textContent = 'Hall of Fame';
      document.getElementById('nameInputContainer').classList.add('hidden');
      displayLeaderboard(false);
    }
    
    function displayLeaderboard(highlightCurrent) {
      const board = getLeaderboard();
      const table = document.getElementById('leaderboardTable');
      table.innerHTML = '';
      
      if (board.length === 0) {
        table.innerHTML = '<div style="text-align: center; padding: 40px; opacity: 0.5;">No scores yet. Be the first!</div>';
        return;
      }
      
      board.forEach((entry, index) => {
        const div = document.createElement('div');
        div.className = 'leaderboard-entry';
        if (highlightCurrent && entry.score === score && entry.name === document.getElementById('nameInput').value.trim().toUpperCase()) {
          div.classList.add('current-player');
        }
        
        div.innerHTML = `
          <div class="leaderboard-rank">${index + 1}</div>
          <div class="leaderboard-name">${entry.name}</div>
          <div class="leaderboard-score">${entry.score}</div>
        `;
        table.appendChild(div);
      });
    }
    
    function backToMenu() {
      leaderboardScreen.classList.add('hidden');
      startScreen.classList.remove('hidden');
      document.body.className = '';
    }
    
    // Allow Enter key to save score
    document.addEventListener('DOMContentLoaded', () => {
      const nameInput = document.getElementById('nameInput');
      if (nameInput) {
        nameInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            saveScore();
          }
        });
      }
      
      // Prevent pull-to-refresh and overscroll on iOS
      document.body.addEventListener('touchmove', (e) => {
        e.preventDefault();
      }, { passive: false });
      
      // Prevent default touch behavior on game container
      const gameContainer = document.getElementById('gameContainer');
      if (gameContainer) {
        gameContainer.addEventListener('touchmove', (e) => {
          e.preventDefault();
        }, { passive: false });
      }
    });
  </script>
</body>
</html>
